<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart City Logic | IoT Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        iot: {
                            bg: '#0f172a',
                            panel: '#1e293b',
                            accent: '#38bdf8',
                            success: '#22c55e',
                            danger: '#ef4444',
                            warning: '#f59e0b'
                        }
                    },
                    fontFamily: {
                        sans: ['Roboto', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    }
                }
            }
        }
    </script>
    <style>
        body {
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
        }

        /* JW Nav Icon */
        .jw-nav {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(56, 189, 248, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid rgba(56, 189, 248, 0.2);
            user-select: none;
            color: #38bdf8;
        }

        .jw-nav:hover {
            background: rgba(56, 189, 248, 0.3);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
        }

        /* Logic Block Styling */
        .logic-row {
            background: #334155;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 8px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            border-left: 4px solid #38bdf8;
            transition: all 0.2s;
        }

        .logic-row:hover {
            background: #475569;
        }

        select {
            background: #1e293b;
            border: 1px solid #64748b;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            outline: none;
        }

        select:focus {
            border-color: #38bdf8;
        }

        .keyword {
            font-weight: bold;
            color: #94a3b8;
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        /* Draggable Items */
        .draggable-tool {
            cursor: grab;
            transition: transform 0.1s;
        }

        .draggable-tool:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        /* Canvas Overlay */
        .canvas-container {
            position: relative;
            background-color: #0f172a;
            background-image:
                linear-gradient(rgba(56, 189, 248, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(56, 189, 248, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
            border-radius: 12px;
            border: 1px solid #334155;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.8);
        }

        /* Animation Classes */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slide-in {
            animation: slideIn 0.3s ease-out forwards;
        }

        /* Smog Overlay */
        #smog-layer {
            position: absolute;
            inset: 0;
            background: #475569;
            pointer-events: none;
            mix-blend-mode: hard-light;
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        /* Game Over Screen */
        #fail-screen {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #fail-screen.visible {
            opacity: 1;
            pointer-events: auto;
        }
    </style>
</head>

<body class="flex flex-col h-screen">

    <!-- Header -->
    <header class="bg-iot-panel border-b border-gray-700 p-3 flex items-center justify-between shrink-0 z-50 h-16">
        <div class="flex items-center gap-4">
            <div class="jw-nav" onclick="location.href='index.html'" title="Back to Hub">JW</div>
            <div>
                <h1 class="font-bold text-lg text-white tracking-tight flex items-center gap-2">
                    <span class="material-icons text-iot-accent">settings_input_antenna</span>
                    Smart City Logic
                </h1>
                <p class="text-[10px] text-gray-400 uppercase tracking-widest font-bold">IoT & Big Data Module</p>
            </div>
        </div>
        <div class="flex items-center gap-4">
            <!-- Play/Pause Control -->
            <button onclick="app.togglePlay()" id="play-btn"
                class="bg-blue-900/50 hover:bg-blue-900 text-blue-200 px-3 py-1.5 rounded text-xs font-bold border border-blue-800 transition flex items-center gap-1">
                <span class="material-icons text-sm">pause</span> PAUSE
            </button>

            <div class="flex flex-col items-end mr-4 border-l border-gray-700 pl-4">
                <div class="text-[10px] text-gray-400">CITY HEALTH</div>
                <div class="flex gap-1">
                    <div id="health-pills" class="flex gap-0.5">
                        <!-- Injected via JS -->
                    </div>
                </div>
            </div>
            <button onclick="app.resetSimulation()"
                class="bg-red-900/50 hover:bg-red-900 text-red-200 px-3 py-1.5 rounded text-xs font-bold border border-red-800 transition">
                RESET CITY
            </button>
        </div>
    </header>

    <!-- Main Workspace -->
    <main class="flex-grow flex flex-col md:flex-row overflow-hidden">

        <!-- Left Panel: Logic Builder & Tools -->
        <aside class="w-full md:w-1/3 min-w-[320px] bg-iot-panel border-r border-gray-700 flex flex-col z-20 shadow-xl">

            <!-- Toolbox (Draggables) -->
            <div class="p-4 border-b border-gray-700 bg-gray-800/50">
                <h2 class="text-xs font-bold text-iot-accent uppercase tracking-wider mb-3 flex items-center gap-2">
                    <span class="material-icons text-sm">build</span> Hardware Toolbox
                </h2>
                <div class="grid grid-cols-2 gap-3">
                    <!-- Traffic Sensor -->
                    <div class="draggable-tool bg-gray-700 p-3 rounded border border-gray-600 flex items-center gap-3 hover:border-iot-accent hover:bg-gray-600 select-none"
                        draggable="true" ondragstart="app.dragStart(event, 'traffic_sensor')">
                        <div
                            class="w-8 h-8 rounded bg-yellow-500/20 flex items-center justify-center text-yellow-500 border border-yellow-500/50">
                            <span class="material-icons text-sm">traffic</span>
                        </div>
                        <div>
                            <div class="text-xs font-bold text-white">Traffic Sensor</div>
                            <div class="text-[10px] text-gray-400">Detects Jams</div>
                        </div>
                    </div>

                    <!-- Air Sensor -->
                    <div class="draggable-tool bg-gray-700 p-3 rounded border border-gray-600 flex items-center gap-3 hover:border-iot-accent hover:bg-gray-600 select-none"
                        draggable="true" ondragstart="app.dragStart(event, 'air_sensor')">
                        <div
                            class="w-8 h-8 rounded bg-green-500/20 flex items-center justify-center text-green-500 border border-green-500/50">
                            <span class="material-icons text-sm">air</span>
                        </div>
                        <div>
                            <div class="text-xs font-bold text-white">Air Monitor</div>
                            <div class="text-[10px] text-gray-400">Detects Smog</div>
                        </div>
                    </div>

                    <!-- Industrial Fan -->
                    <div class="draggable-tool bg-gray-700 p-3 rounded border border-gray-600 flex items-center gap-3 hover:border-iot-accent hover:bg-gray-600 select-none col-span-2"
                        draggable="true" ondragstart="app.dragStart(event, 'fan')">
                        <div
                            class="w-8 h-8 rounded bg-blue-500/20 flex items-center justify-center text-blue-500 border border-blue-500/50">
                            <span class="material-icons text-sm">cyclone</span>
                        </div>
                        <div>
                            <div class="text-xs font-bold text-white">Industrial Fan</div>
                            <div class="text-[10px] text-gray-400">Clears Pollution (Place on Map)</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Logic Editor -->
            <div class="flex-grow flex flex-col p-4 overflow-hidden">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xs font-bold text-iot-accent uppercase tracking-wider flex items-center gap-2">
                        <span class="material-icons text-sm">code</span> Logic Controller
                    </h2>
                    <button onclick="app.addRule()"
                        class="text-xs bg-blue-600 hover:bg-blue-500 text-white px-2 py-1 rounded flex items-center gap-1">
                        <span class="material-icons text-[12px]">add</span> Add Rule
                    </button>
                </div>

                <div id="logic-container" class="flex-grow overflow-y-auto pr-1 space-y-2 pb-4">
                    <!-- Rules injected here -->
                    <div class="text-center text-gray-500 text-xs mt-10 italic" id="empty-rules">
                        No logic defined.<br>
                        Tip: Use 'Maintenance Crew' to clear crashes.
                    </div>
                </div>

                <div class="mt-auto pt-4 border-t border-gray-700">
                    <div class="bg-gray-900 rounded p-3 text-[10px] font-mono text-gray-400 border border-gray-700">
                        <div class="flex items-center gap-2 mb-1">
                            <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                            <span>SYSTEM STATUS: ONLINE</span>
                        </div>
                        <div>Active Sensors: <span id="sensor-count" class="text-white">0</span></div>
                        <div>Active Rules: <span id="rule-count" class="text-white">0</span></div>
                    </div>
                    <div class="text-center text-[10px] text-gray-600 mt-2">
                        Made by James Williams. MIT Licensed.
                    </div>
                </div>
            </div>
        </aside>

        <!-- Right Panel: Simulation Canvas -->
        <main class="flex-grow relative bg-gray-900 p-4 flex flex-col">
            <div class="canvas-container flex-grow w-full h-full relative" id="drop-zone"
                ondragover="app.dragOver(event)" ondrop="app.drop(event)">
                <canvas id="cityCanvas" class="block w-full h-full"></canvas>

                <!-- Smog Visual Layer -->
                <div id="smog-layer" style="opacity: 0;"></div>

                <!-- Game Over Screen -->
                <div id="fail-screen">
                    <span class="material-icons text-6xl text-red-500 mb-4">warning</span>
                    <h2 class="text-3xl font-bold text-white mb-2">CITY EVACUATED</h2>
                    <p class="text-red-300 mb-6">Critical pollution levels reached.</p>
                    <button onclick="app.resetSimulation()"
                        class="bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded font-bold">
                        REBOOT SYSTEM
                    </button>
                </div>

                <!-- Overlay UI on Canvas -->
                <div
                    class="absolute top-4 left-4 bg-gray-900/80 backdrop-blur border border-gray-700 p-2 rounded text-xs text-gray-300 pointer-events-none z-20">
                    <div class="font-bold text-white mb-1">City Legend (UK Rules)</div>
                    <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-blue-500 rounded-sm"></span> Fan
                        (Actuator)</div>
                    <div class="flex items-center gap-2 mb-1"><span class="w-3 h-3 bg-red-500 rounded-full"></span>
                        Traffic Light</div>
                    <div class="flex items-center gap-2 mb-1"><span
                            class="w-3 h-3 border border-dashed border-gray-400 rounded-full"></span> Sensor Zone</div>
                    <div class="flex items-center gap-2"><span class="w-3 h-3 bg-orange-500 rounded-sm"></span> Maint.
                        Depot</div>
                </div>

                <div id="notification-area"
                    class="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex flex-col gap-2 items-center pointer-events-none z-30">
                    <!-- Dynamic Toasts -->
                </div>
            </div>
        </main>
    </main>

    <script>
        /**
         * SMART CITY ENGINE
         */
        const app = {
            canvas: document.getElementById('cityCanvas'),
            ctx: null,
            width: 0,
            height: 0,

            // Simulation State
            cars: [],
            lights: [],
            fans: [],
            sensors: [],
            pollution: [],
            rules: [],
            activeConnections: [],
            depotLocation: { x: 0, y: 0 },

            // Logic State
            sensorCounter: 1,
            fanCounter: 1,
            cityHealth: 100,
            gameOver: false,
            isPlaying: true, // Play/Pause State

            // Drag State
            draggedEntity: null,
            isDraggingMapItem: false,

            init() {
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());

                // Add Map Interaction Listeners
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));

                this.setupCity();

                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);

                this.updateHealthUI();
            },

            handleMouseDown(e) {
                if (this.gameOver) return;
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Check sensors (topmost first)
                for (let i = this.sensors.length - 1; i >= 0; i--) {
                    const s = this.sensors[i];
                    if (Math.hypot(s.x - x, s.y - y) < 20) { // Click radius
                        this.draggedEntity = s;
                        this.isDraggingMapItem = true;
                        return;
                    }
                }

                // Check fans
                for (let i = this.fans.length - 1; i >= 0; i--) {
                    const f = this.fans[i];
                    if (Math.hypot(f.x - x, f.y - y) < 20) {
                        this.draggedEntity = f;
                        this.isDraggingMapItem = true;
                        return;
                    }
                }
            },

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Change cursor style if hovering over movable item
                let hovering = false;
                if (!this.isDraggingMapItem) {
                    for (const s of this.sensors) if (Math.hypot(s.x - x, s.y - y) < 20) hovering = true;
                    for (const f of this.fans) if (Math.hypot(f.x - x, f.y - y) < 20) hovering = true;
                    this.canvas.style.cursor = hovering ? 'pointer' : 'default';
                }

                // Handle actual dragging
                if (this.isDraggingMapItem && this.draggedEntity) {
                    this.draggedEntity.x = x;
                    this.draggedEntity.y = y;
                    this.canvas.style.cursor = 'grabbing';
                }
            },

            handleMouseUp(e) {
                this.isDraggingMapItem = false;
                this.draggedEntity = null;
                this.canvas.style.cursor = 'default';
            },

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                const btn = document.getElementById('play-btn');
                if (this.isPlaying) {
                    btn.innerHTML = '<span class="material-icons text-sm">pause</span> PAUSE';
                    btn.className = btn.className.replace('bg-green-900', 'bg-blue-900').replace('border-green-800', 'border-blue-800').replace('text-green-200', 'text-blue-200');
                } else {
                    btn.innerHTML = '<span class="material-icons text-sm">play_arrow</span> PLAY';
                    btn.className = btn.className.replace('bg-blue-900', 'bg-green-900').replace('border-blue-800', 'border-green-800').replace('text-blue-200', 'text-green-200');
                }
            },

            resize() {
                const rect = document.getElementById('drop-zone').getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.width = rect.width;
                this.height = rect.height;
                if (!this.gameOver) this.setupCity();
            },

            setupCity() {
                this.lights = [];
                // Clear fans (they are now user-placeable, though we can keep some defaults if preferred)
                this.fans = [];
                this.activeConnections = [];

                const cx = this.width / 2;
                const cy = this.height / 2;

                // Traffic Lights (UK Left Side Positions)
                this.lights.push(new TrafficLight(1, cx - 22, cy + 55, 'Northbound (L1)'));
                this.lights.push(new TrafficLight(2, cx + 22, cy - 55, 'Southbound (L2)'));
                this.lights.push(new TrafficLight(3, cx - 55, cy + 22, 'Eastbound (L3)'));
                this.lights.push(new TrafficLight(4, cx + 55, cy - 22, 'Westbound (L4)'));

                // Maintenance Depot (Fixed Location)
                this.depotLocation = { x: this.width - 60, y: 60 };
            },

            // --- Drag & Drop Handling ---

            dragStart(e, type) {
                e.dataTransfer.setData('sensorType', type);
            },

            dragOver(e) {
                e.preventDefault();
            },

            drop(e) {
                e.preventDefault();
                if (this.gameOver) return;

                const type = e.dataTransfer.getData('sensorType');
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (type === 'traffic_sensor') {
                    this.addSensor(new TrafficSensor(this.sensorCounter++, x, y));
                    this.showToast('Traffic Sensor Installed', 'success');
                } else if (type === 'air_sensor') {
                    this.addSensor(new AirSensor(this.sensorCounter++, x, y));
                    this.showToast('Air Quality Monitor Installed', 'success');
                } else if (type === 'fan') {
                    this.fans.push(new Fan(this.fanCounter++, x, y));
                    this.showToast('Industrial Fan Deployed', 'success');
                    this.refreshRuleDropdowns();
                }

                this.updateUI();
            },

            addSensor(sensor) {
                this.sensors.push(sensor);
                this.refreshRuleDropdowns();
            },

            // --- Logic Builder ---

            addRule() {
                const container = document.getElementById('logic-container');
                document.getElementById('empty-rules').style.display = 'none';

                const div = document.createElement('div');
                div.className = 'logic-row slide-in';

                div.innerHTML = `
                    <span class="keyword">IF</span>
                    <select class="sensor-select"><option>Loading...</option></select>
                    <span class="keyword">DETECTS</span>
                    <select class="condition-select">
                        <option value="high">High Levels</option>
                        <option value="low">Low Levels</option>
                    </select>
                    <span class="keyword">THEN SET</span>
                    <select class="actuator-select"><option>Loading...</option></select>
                    <span class="keyword">TO</span>
                    <select class="state-select">
                        <option value="active">Green / On</option>
                        <option value="active_exclusive">Green (Exclusive)</option>
                        <option value="inactive">Red / Off</option>
                    </select>
                    <button class="ml-auto text-gray-500 hover:text-red-400" onclick="this.parentElement.remove(); app.updateUI()">
                        <span class="material-icons text-sm">delete</span>
                    </button>
                `;

                container.appendChild(div);
                this.refreshRuleDropdowns();
                this.updateUI();
            },

            refreshRuleDropdowns() {
                const sensorOptions = this.sensors.length > 0
                    ? this.sensors.map(s => `<option value="${s.id}">${s.name}</option>`).join('')
                    : '<option value="">No Sensors Available</option>';

                const actuatorOptions = [
                    ...this.lights.map(l => `<option value="L${l.id}">Light ${l.id} (${l.orientation.split(' ')[0]})</option>`),
                    ...this.fans.map(f => `<option value="F${f.id}">Fan ${f.id}</option>`),
                    `<option value="MAINT">Maintenance Crew</option>` // NEW OPTION
                ].join('');

                const rows = document.querySelectorAll('.logic-row');
                rows.forEach(row => {
                    const sensorSelect = row.querySelector('.sensor-select');
                    const savedSensor = sensorSelect.value;
                    sensorSelect.innerHTML = sensorOptions;
                    if (savedSensor && this.sensors.find(s => s.id == savedSensor)) sensorSelect.value = savedSensor;

                    const actuatorSelect = row.querySelector('.actuator-select');
                    const savedActuator = actuatorSelect.value;
                    actuatorSelect.innerHTML = actuatorOptions;
                    if (savedActuator) actuatorSelect.value = savedActuator;
                });
            },

            evaluateLogic() {
                const rows = document.querySelectorAll('.logic-row');
                this.activeConnections = [];

                rows.forEach(row => {
                    const sensorId = parseInt(row.querySelector('.sensor-select').value);
                    const condition = row.querySelector('.condition-select').value;
                    const actuatorId = row.querySelector('.actuator-select').value;
                    const state = row.querySelector('.state-select').value;

                    const sensor = this.sensors.find(s => s.id === sensorId);
                    if (!sensor) return;

                    let conditionMet = false;
                    if (sensor.type === 'traffic') {
                        conditionMet = (condition === 'high' && sensor.value > 1) || (condition === 'low' && sensor.value <= 1);
                    } else if (sensor.type === 'air') {
                        conditionMet = (condition === 'high' && sensor.value > 10) || (condition === 'low' && sensor.value <= 10);
                    }

                    if (conditionMet) {
                        sensor.triggered = true;
                        let targetLoc = null;

                        if (actuatorId === 'MAINT') {
                            if (state === 'active' || state === 'active_exclusive') {
                                this.clearCrashes();
                                targetLoc = this.depotLocation;
                            }
                        }
                        else if (actuatorId.startsWith('L')) {
                            const light = this.lights.find(l => l.id == actuatorId.substring(1));
                            if (light) {
                                if (state === 'active_exclusive') {
                                    this.lights.forEach(l => l.state = 'red');
                                    light.state = 'green';
                                } else {
                                    light.state = (state === 'active' ? 'green' : 'red');
                                }
                                targetLoc = { x: light.x, y: light.y };
                            }
                        }
                        else if (actuatorId.startsWith('F')) {
                            const fan = this.fans.find(f => f.id == actuatorId.substring(1));
                            if (fan) {
                                fan.active = (state === 'active' || state === 'active_exclusive');
                                targetLoc = { x: fan.x, y: fan.y };
                            }
                        }

                        if (targetLoc) {
                            this.activeConnections.push({
                                start: { x: sensor.x, y: sensor.y },
                                end: targetLoc
                            });
                        }
                    } else {
                        sensor.triggered = false;
                    }
                });
            },

            clearCrashes() {
                // Remove any crashed car instantly
                this.cars.forEach(c => {
                    if (c.crashed && !c.beingTowed) {
                        c.beingTowed = true;
                        // Visual effect handled in draw
                    }
                });
            },

            checkCollisions() {
                for (let i = 0; i < this.cars.length; i++) {
                    for (let j = i + 1; j < this.cars.length; j++) {
                        const c1 = this.cars[i];
                        const c2 = this.cars[j];

                        if (c1.crashed || c2.crashed) continue;

                        // Check collision distance based on vehicle type (length)
                        // Using a simple approximation of size for collision
                        const minDist = (c1.length + c2.length) / 3; // Approx overlap threshold
                        const dist = Math.hypot(c1.x - c2.x, c1.y - c2.y);

                        if (dist < minDist) {
                            c1.crashed = true;
                            c2.crashed = true;
                            c1.stopped = true;
                            c2.stopped = true;
                            // Add extra crash pollution burst
                            for (let p = 0; p < 10; p++) this.pollution.push(new Cloud(c1.x, c1.y, true));
                            this.showToast('ACCIDENT DETECTED!', 'danger');
                        }
                    }
                }
            },

            // --- Simulation Loop ---

            loop() {
                // Always redraw canvas even if paused
                this.ctx.fillStyle = '#0f172a';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.drawBuildings();
                this.drawRoads();
                this.drawDataLines();
                this.drawDepot();
                this.fans.forEach(fan => fan.draw(this.ctx));
                this.lights.forEach(light => light.draw(this.ctx));
                this.sensors.forEach(sensor => sensor.draw(this.ctx));

                // Keep drawing cars/pollution even if paused, just don't update positions
                this.cars.forEach(car => car.draw(this.ctx));
                this.pollution.forEach(p => p.draw(this.ctx));

                if (!this.gameOver && this.isPlaying) {
                    if (Math.random() < 0.025) this.spawnCar(); // Slightly more traffic

                    this.updatePollution();

                    // Update Entities
                    this.fans.forEach(fan => fan.update());
                    this.sensors.forEach(sensor => sensor.update(this.cars, this.pollution));

                    this.cars = this.cars.filter(car => {
                        car.update(this.lights, this.cars);
                        return !car.dead;
                    });

                    this.checkCollisions();
                    this.evaluateLogic();

                    this.updateHealthUI();

                    if (this.cityHealth <= 0) this.triggerGameOver();
                }

                requestAnimationFrame(this.loop);
            },

            spawnCar() {
                const axes = ['N', 'S', 'E', 'W'];
                const axis = axes[Math.floor(Math.random() * axes.length)];
                const cx = this.width / 2;
                const cy = this.height / 2;

                // Random Vehicle Type
                const rand = Math.random();
                let type = 'car';
                if (rand > 0.75) type = 'truck';
                if (rand > 0.90) type = 'bus';

                let x, y, vx, vy, laneLightId;

                if (axis === 'N') { x = cx - 22; y = this.height + 50; vx = 0; vy = -2; laneLightId = 1; }
                else if (axis === 'S') { x = cx + 22; y = -50; vx = 0; vy = 2; laneLightId = 2; }
                else if (axis === 'E') { x = -50; y = cy + 22; vx = 2; vy = 0; laneLightId = 3; }
                else if (axis === 'W') { x = this.width + 50; y = cy - 22; vx = -2; vy = 0; laneLightId = 4; }

                const isBlocked = this.cars.some(c => Math.hypot(c.x - x, c.y - y) < 80);

                if (!isBlocked) {
                    this.cars.push(new Car(x, y, vx, vy, laneLightId, type));
                }
            },

            drawBuildings() {
                this.ctx.fillStyle = '#1e293b';
                this.ctx.strokeStyle = '#38bdf8';
                this.ctx.lineWidth = 1;

                const roadW = 90;
                const cx = this.width / 2;
                const cy = this.height / 2;

                const blocks = [
                    { x: 20, y: 20, w: cx - roadW - 40, h: cy - roadW - 40 },
                    { x: cx + roadW + 20, y: 20, w: cx - roadW - 40, h: cy - roadW - 40 },
                    { x: 20, y: cy + roadW + 20, w: cx - roadW - 40, h: cy - roadW - 40 },
                    { x: cx + roadW + 20, y: cy + roadW + 20, w: cx - roadW - 40, h: cy - roadW - 40 }
                ];

                blocks.forEach(b => {
                    if (b.w > 0 && b.h > 0) {
                        this.ctx.fillRect(b.x, b.y, b.w, b.h);
                        this.ctx.shadowBlur = 5;
                        this.ctx.shadowColor = '#38bdf8';
                        this.ctx.strokeRect(b.x, b.y, b.w, b.h);
                        this.ctx.shadowBlur = 0;

                        this.ctx.fillStyle = '#0f172a';
                        // Draw windows
                        for (let wx = b.x + 10; wx < b.x + b.w - 10; wx += 20) {
                            for (let wy = b.y + 10; wy < b.y + b.h - 10; wy += 20) {
                                // Pseudo-random check based on coordinates to keep lights static (no flickering)
                                const seed = (Math.floor(wx) * 11 + Math.floor(wy) * 13) % 100;

                                if (seed > 65) { // 35% chance to be lit
                                    // Consistent color choice based on seed
                                    this.ctx.fillStyle = (seed % 2 === 0) ? '#fef08a' : '#22d3ee';
                                    this.ctx.fillRect(wx, wy, 10, 10);
                                } else {
                                    // Dark window
                                    this.ctx.fillStyle = '#0f172a';
                                    this.ctx.fillRect(wx, wy, 10, 10);
                                }
                            }
                        }
                    }
                });
            },

            drawRoads() {
                const cx = this.width / 2;
                const cy = this.height / 2;
                const roadWidth = 90;

                this.ctx.fillStyle = '#0f172a';
                this.ctx.fillRect(0, cy - roadWidth / 2, this.width, roadWidth);
                this.ctx.fillRect(cx - roadWidth / 2, 0, roadWidth, this.height);

                this.ctx.strokeStyle = '#64748b';
                this.ctx.lineWidth = 2;

                this.ctx.beginPath();
                this.ctx.moveTo(0, cy - roadWidth / 2); this.ctx.lineTo(this.width, cy - roadWidth / 2);
                this.ctx.moveTo(0, cy + roadWidth / 2); this.ctx.lineTo(this.width, cy + roadWidth / 2);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(cx - roadWidth / 2, 0); this.ctx.lineTo(cx - roadWidth / 2, this.height);
                this.ctx.moveTo(cx + roadWidth / 2, 0); this.ctx.lineTo(cx + roadWidth / 2, this.height);
                this.ctx.stroke();

                this.ctx.strokeStyle = '#475569';
                this.ctx.setLineDash([15, 15]);
                this.ctx.beginPath();
                this.ctx.moveTo(0, cy); this.ctx.lineTo(this.width, cy);
                this.ctx.moveTo(cx, 0); this.ctx.lineTo(cx, this.height);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            },

            drawDepot() {
                const x = this.depotLocation.x;
                const y = this.depotLocation.y;

                this.ctx.fillStyle = '#f97316';
                this.ctx.fillRect(x - 20, y - 20, 40, 40);
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x - 20, y - 20, 40, 40);

                this.ctx.fillStyle = '#fff';
                this.ctx.font = 'bold 10px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('DEPOT', x, y + 4);
            },

            drawDataLines() {
                if (this.activeConnections.length === 0) return;

                this.ctx.lineWidth = 2;
                this.activeConnections.forEach(conn => {
                    const grad = this.ctx.createLinearGradient(conn.start.x, conn.start.y, conn.end.x, conn.end.y);
                    grad.addColorStop(0, '#22c55e');
                    grad.addColorStop(1, '#38bdf8');

                    this.ctx.strokeStyle = grad;
                    this.ctx.beginPath();
                    this.ctx.moveTo(conn.start.x, conn.start.y);
                    this.ctx.lineTo(conn.end.x, conn.end.y);
                    this.ctx.stroke();

                    const time = Date.now() / 500;
                    const progress = time % 1;
                    const dx = conn.end.x - conn.start.x;
                    const dy = conn.end.y - conn.start.y;

                    this.ctx.fillStyle = '#fff';
                    this.ctx.beginPath();
                    this.ctx.arc(conn.start.x + dx * progress, conn.start.y + dy * progress, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            },

            updatePollution() {
                this.cars.forEach(car => {
                    // Crashed cars emit A LOT more pollution
                    if (car.crashed) {
                        if (Math.random() < 0.3) this.pollution.push(new Cloud(car.x, car.y, true));
                    } else {
                        // Midpoint Difficulty: 2% chance (was 3%, originally 1%)
                        if (Math.random() < 0.02) this.pollution.push(new Cloud(car.x, car.y));
                    }
                });

                this.fans.forEach(fan => {
                    if (fan.active) {
                        this.pollution = this.pollution.filter(p => {
                            const d = Math.hypot(p.x - fan.x, p.y - fan.y);
                            return d > 180;
                        });

                        if (Math.random() < 0.3) {
                            this.ctx.fillStyle = 'rgba(56, 189, 248, 0.3)';
                            const ang = Math.random() * Math.PI * 2;
                            const r = Math.random() * 150;
                            this.ctx.beginPath();
                            this.ctx.arc(fan.x + Math.cos(ang) * r, fan.y + Math.sin(ang) * r, 1, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                });

                this.pollution.forEach(p => {
                    p.update();
                    p.draw(this.ctx);
                });

                this.pollution = this.pollution.filter(p => p.life > 0);
            },

            updateUI() {
                document.getElementById('sensor-count').innerText = this.sensors.length;
                document.getElementById('rule-count').innerText = document.querySelectorAll('.logic-row').length;
            },

            updateHealthUI() {
                const count = this.pollution.length;
                // Midpoint Difficulty: 0.4 multiplier (was 0.8, originally 0.2)
                this.cityHealth = Math.max(0, 100 - (count * 0.4));

                const smogOpacity = (100 - this.cityHealth) / 100; // Cap at 1.0
                document.getElementById('smog-layer').style.opacity = Math.min(0.9, smogOpacity);

                const pillsContainer = document.getElementById('health-pills');
                pillsContainer.innerHTML = '';
                const bars = Math.ceil(this.cityHealth / 10);

                for (let i = 0; i < 10; i++) {
                    const div = document.createElement('div');
                    div.className = `w-3 h-2 rounded-sm ${i < bars ? 'bg-green-500' : 'bg-gray-700'}`;
                    if (this.cityHealth < 40 && i < bars) div.className = div.className.replace('bg-green-500', 'bg-red-500');
                    pillsContainer.appendChild(div);
                }
            },

            triggerGameOver() {
                this.gameOver = true;
                document.getElementById('fail-screen').classList.add('visible');
            },

            showToast(msg, type) {
                const div = document.createElement('div');
                div.className = `bg-gray-800 text-white px-4 py-2 rounded shadow-lg border-l-4 ${type === 'success' ? 'border-green-500' : 'border-blue-500'} ${type === 'danger' ? 'border-red-500' : ''} fade-in`;
                div.innerText = msg;
                document.getElementById('notification-area').appendChild(div);
                setTimeout(() => div.remove(), 2000);
            },

            resetSimulation() {
                this.cars = [];
                this.pollution = [];
                this.sensors = [];
                this.fans = [];
                this.gameOver = false;
                this.isPlaying = true; // Auto-play on reset
                document.getElementById('fail-screen').classList.remove('visible');
                document.getElementById('smog-layer').style.opacity = 0;

                this.setupCity();

                document.getElementById('logic-container').innerHTML = `<div class="text-center text-gray-500 text-xs mt-10 italic" id="empty-rules">No logic defined.<br>Tip: Use 'Green (Exclusive)' to prevent crashes.</div>`;
                this.rules = [];

                this.updateUI();
                this.updateHealthUI();

                if (!this.gameOver) requestAnimationFrame(this.loop);
            }
        };

        /**
         * ENTITY CLASSES
         */

        class Car {
            constructor(x, y, vx, vy, lightId, type = 'car') {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.laneLightId = lightId;
                this.type = type;
                this.dead = false;
                this.stopped = false;
                this.crashed = false;
                this.beingTowed = false;
                this.crashTimer = 0;

                // Properties based on type
                if (type === 'bus') {
                    this.length = 24;
                    this.width = 11;
                    this.speed = 1.5;
                    this.color = Math.random() > 0.5 ? '#ef4444' : '#3b82f6'; // Red or Blue bus
                } else if (type === 'truck') {
                    this.length = 20;
                    this.width = 12;
                    this.speed = 1.8;
                    this.color = '#9ca3af'; // Grey
                } else {
                    this.length = 12;
                    this.width = 10;
                    this.speed = 2.5;
                    this.color = `hsl(${Math.random() * 360}, 80%, 60%)`;
                }

                // Scale velocity by speed
                if (this.vx !== 0) this.vx = Math.sign(this.vx) * this.speed;
                if (this.vy !== 0) this.vy = Math.sign(this.vy) * this.speed;
            }
            update(lights, otherCars) {
                if (this.beingTowed) {
                    const dx = app.depotLocation.x - this.x;
                    const dy = app.depotLocation.y - this.y;
                    this.x += dx * 0.1;
                    this.y += dy * 0.1;
                    if (Math.hypot(dx, dy) < 10) this.dead = true;
                    return;
                }

                if (this.crashed) {
                    this.crashTimer++;
                    if (this.crashTimer > 600) {
                        this.dead = true;
                    }
                    return;
                }

                this.stopped = false;

                // 1. Check My Specific Traffic Light
                const light = lights.find(l => l.id === this.laneLightId);
                if (light && light.state === 'red') {
                    const d = Math.hypot(this.x - light.x, this.y - light.y);
                    let shouldStop = false;
                    if (d < 60) {
                        if (this.vy < 0 && this.y > light.y) shouldStop = true;
                        if (this.vy > 0 && this.y < light.y) shouldStop = true;
                        if (this.vx > 0 && this.x < light.x) shouldStop = true;
                        if (this.vx < 0 && this.x > light.x) shouldStop = true;
                    }
                    if (shouldStop) {
                        this.stopped = true;
                    }
                }

                // 2. Queueing (Check Car Ahead)
                if (!this.stopped) {
                    const carAhead = otherCars.find(c => {
                        if (c === this) return false;

                        // Treat crashed cars as circular obstacles
                        if (c.crashed || c.beingTowed) {
                            const d = Math.hypot(this.x - c.x, this.y - c.y);
                            if (d < 35) return true;
                            return false;
                        }

                        // IGNORE cross-traffic to prevent gridlock
                        const myVertical = this.vy !== 0;
                        const otherVertical = c.vy !== 0;
                        const myHorizontal = this.vx !== 0;
                        const otherHorizontal = c.vx !== 0;

                        if (myVertical && otherHorizontal && !c.stopped) return false;
                        if (myHorizontal && otherVertical && !c.stopped) return false;

                        // Standard Queue Logic - Adjusted for vehicle length
                        const stopDist = this.length / 2 + c.length / 2 + 10;

                        if (this.vy < 0 && c.y < this.y && c.y > this.y - 60 && Math.abs(c.x - this.x) < 12) return true;
                        if (this.vy > 0 && c.y > this.y && c.y < this.y + 60 && Math.abs(c.x - this.x) < 12) return true;
                        if (this.vx > 0 && c.x > this.x && c.x < this.x + 60 && Math.abs(c.y - this.y) < 12) return true;
                        if (this.vx < 0 && c.x < this.x && c.x > this.x - 60 && Math.abs(c.y - this.y) < 12) return true;

                        return false;
                    });
                    if (carAhead) this.stopped = true;
                }

                if (!this.stopped) {
                    this.x += this.vx;
                    this.y += this.vy;
                }

                if (this.x > app.width + 50 || this.x < -50 || this.y > app.height + 50 || this.y < -50) this.dead = true;
            }
            draw(ctx) {
                if (this.beingTowed) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#f97316';
                    ctx.fillRect(this.x - 6, this.y - 6, 12, 12);
                    ctx.globalAlpha = 1;
                    return;
                }

                if (this.crashed) {
                    ctx.globalAlpha = Math.max(0, 1 - (this.crashTimer / 600));
                    ctx.fillStyle = '#1f2937';
                    // Draw somewhat boxy wreckage
                    ctx.fillRect(this.x - this.width / 2, this.y - this.length / 2, this.width, this.length);
                    ctx.fillStyle = `rgba(239, 68, 68, ${Math.random()})`;
                    ctx.beginPath();
                    ctx.arc(this.x + (Math.random() * 4 - 2), this.y + (Math.random() * 4 - 2), 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    return;
                }

                ctx.fillStyle = this.color;
                ctx.shadowBlur = 5;
                ctx.shadowColor = this.color;

                // Draw based on orientation and type dimensions
                let dimX = this.length;
                let dimY = this.width;
                if (this.vy !== 0) { // Vertical
                    dimX = this.width;
                    dimY = this.length;
                }

                ctx.fillRect(this.x - dimX / 2, this.y - dimY / 2, dimX, dimY);
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#fff';
                // Headlights
                if (this.vx > 0) ctx.fillRect(this.x + dimX / 2 - 2, this.y - dimY / 2 + 2, 2, dimY - 4);
                if (this.vx < 0) ctx.fillRect(this.x - dimX / 2, this.y - dimY / 2 + 2, 2, dimY - 4);
                if (this.vy > 0) ctx.fillRect(this.x - dimX / 2 + 2, this.y + dimY / 2 - 2, dimX - 4, 2);
                if (this.vy < 0) ctx.fillRect(this.x - dimX / 2 + 2, this.y - dimY / 2, dimX - 4, 2);
            }
        }

        // ... (TrafficLight, Fan, Cloud, TrafficSensor, AirSensor classes remain identical)
        // Re-included for completeness

        class TrafficLight {
            constructor(id, x, y, orientation) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.state = 'red';
                this.orientation = orientation;
            }
            draw(ctx) {
                ctx.fillStyle = '#111';
                ctx.fillRect(this.x - 12, this.y - 12, 24, 24);

                const color = this.state === 'green' ? '#22c55e' : '#ef4444';
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowColor = color;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`L${this.id}`, this.x, this.y);
            }
        }

        class Fan {
            constructor(id, x, y) {
                this.id = id;
                this.name = `Fan ${id}`;
                this.x = x;
                this.y = y;
                this.active = false;
                this.angle = 0;
            }
            update() {
                if (this.active) this.angle += 0.5;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = '#334155';
                ctx.beginPath();
                ctx.arc(0, 0, 16, 0, Math.PI * 2);
                ctx.fill();

                ctx.rotate(this.angle);
                ctx.strokeStyle = this.active ? '#38bdf8' : '#94a3b8';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-12, 0); ctx.lineTo(12, 0);
                ctx.moveTo(0, -12); ctx.lineTo(0, 12);
                ctx.stroke();

                if (this.active) {
                    ctx.strokeStyle = 'rgba(56, 189, 248, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, 150, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();

                ctx.fillStyle = '#94a3b8';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`F${this.id}`, this.x, this.y + 28);
            }
        }

        class Cloud {
            constructor(x, y, isSmoke = false) {
                this.x = x + (Math.random() * 20 - 10);
                this.y = y + (Math.random() * 20 - 10);
                this.size = Math.random() * 10 + 5;
                this.life = 1.0;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.isSmoke = isSmoke;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.size += 0.1;
                this.life -= 0.002;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life * 0.4);
                ctx.fillStyle = this.isSmoke ? '#1f2937' : '#64748b';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        class TrafficSensor {
            constructor(id, x, y) {
                this.id = id;
                this.name = `Sensor ${id}`;
                this.x = x;
                this.y = y;
                this.value = 0;
                this.type = 'traffic';
                this.triggered = false;
            }
            update(cars) {
                this.value = 0;
                cars.forEach(c => {
                    if (Math.hypot(c.x - this.x, c.y - this.y) < 50) this.value++;
                });
            }
            draw(ctx) {
                ctx.strokeStyle = this.triggered ? '#fbbf24' : '#eab308';
                ctx.lineWidth = this.triggered ? 3 : 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, 50, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#eab308';
                ctx.fillRect(this.x - 5, this.y - 5, 10, 10);

                if (this.triggered) {
                    ctx.shadowColor = '#eab308';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(this.x - 5, this.y - 5, 10, 10);
                    ctx.shadowBlur = 0;
                }

                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.fillText(`Cars: ${this.value}`, this.x + 12, this.y);
            }
        }

        class AirSensor {
            constructor(id, x, y) {
                this.id = id;
                this.name = `AirMon ${id}`;
                this.x = x;
                this.y = y;
                this.value = 0;
                this.type = 'air';
                this.triggered = false;
            }
            update(cars, clouds) {
                this.value = 0;
                clouds.forEach(c => {
                    if (Math.hypot(c.x - this.x, c.y - this.y) < 50) this.value++;
                });
            }
            draw(ctx) {
                ctx.strokeStyle = this.triggered ? '#4ade80' : '#22c55e';
                ctx.lineWidth = this.triggered ? 3 : 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(this.x, this.y, 50, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#22c55e';
                ctx.fillRect(this.x - 5, this.y - 5, 10, 10);

                if (this.triggered) {
                    ctx.shadowColor = '#22c55e';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(this.x - 5, this.y - 5, 10, 10);
                    ctx.shadowBlur = 0;
                }

                ctx.fillStyle = '#fff';
                ctx.font = '10px sans-serif';
                ctx.fillText(`AQI: ${this.value}`, this.x + 12, this.y);
            }
        }

        // Boot
        window.onload = () => app.init();
    </script>
</body>

</html>